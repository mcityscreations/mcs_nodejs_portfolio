  import { injectable } from 'tsyringe';
  import { RecaptchaEnterpriseServiceClient } from "@google-cloud/recaptcha-enterprise";
  import { HttpError } from "../../system/errorHandler/httpError";
  import { ISecurityEvaluationResult } from "../securityInterface";

 /**
  * Creates an assessment to analyze the risk of a user action.
  * 
  * projectID: The ID of the Google Cloud project.
  * recaptchaKey: The reCAPTCHA key associated to the application
  * token: Token generated by the reCAPTCHA client-side integration on the website.
  * recaptchaAction: Action name to be verified, must match the one provided during token generation.
  */

@injectable()
export class RecaptchaService {

  private RECAPTCHA_PROJECT_ID;
  private RECAPTCHA_KEY;
  private GOOGLE_APPLICATION_CREDENTIALS;
  private _client: RecaptchaEnterpriseServiceClient;

  // Recaptcha thresholds
  private readonly BLOCK_THRESHOLD = 0.1;
  private readonly MFA_THRESHOLD = 0.9;

  constructor() {

    const projetID = process.env.RECAPTCHA_PROJECT_ID;
    const recaptchaKey = process.env.RECAPTCHA_KEY;
    const googleCredentials = process.env.GOOGLE_APPLICATION_CREDENTIALS;

    if (!projetID || projetID === "") { throw new HttpError("RECAPTCHA_PROJECT_ID is not defined in environment variables.", 500, false); }
    if (!recaptchaKey || recaptchaKey === "") { throw new HttpError("RECAPTCHA_KEY is not defined in environment variables.", 500, false); }
    if (!googleCredentials || googleCredentials === "") { throw new HttpError("GOOGLE_APPLICATION_CREDENTIALS is not defined in environment variables.", 500, false); }

    this.RECAPTCHA_PROJECT_ID = projetID;
    this.RECAPTCHA_KEY = recaptchaKey;
    this.GOOGLE_APPLICATION_CREDENTIALS = googleCredentials; 

    // Creating Recaptcha client
    this._client = new RecaptchaEnterpriseServiceClient({  
        keyFile: this.GOOGLE_APPLICATION_CREDENTIALS
    });
  }

  public async createAssessment(token: string, actionName: string) {
    // Retrieving the project path
    const projectPath = this._client.projectPath(this.RECAPTCHA_PROJECT_ID);

    // Creating the assessment request
    const request = ({
      assessment: {
        event: {
          token: token,
          siteKey: this.RECAPTCHA_KEY,
        },
      },
      parent: projectPath,
    });

    try {
        const [ response ] = await this._client.createAssessment(request);

        // 1. Checking token validity (User error - 400 Bad Request)
        if (!response?.tokenProperties?.valid ) {
            console.warn(`Token reCAPTCHA invalide: ${response?.tokenProperties?.invalidReason}`);
            throw new HttpError("Le jeton reCAPTCHA est invalide ou expiré.", 400, true);
        }

        // 2. Checking action name consistency (User error - 400 Bad Request)
        if (response.tokenProperties.action !== actionName) {
            console.warn(`Action reCAPTCHA incohérente: attendu ${actionName}, reçu ${response.tokenProperties.action}`);
            throw new HttpError("L'action reCAPTCHA ne correspond pas à l'action attendue.", 400, true);
        }

        // 3. Success
        return response?.riskAnalysis?.score || 0; // Returns 0 by default if score is undefined

    } catch (error) {
        // 4. Handling external HTTP errors
        if (error instanceof HttpError) {
            throw error; // Rethrowing HttpError generated by this Mcitys API.
        }
        
        // Error 503 - Service Unavailable
        console.error("Erreur de communication avec l'API reCAPTCHA:", error);
        throw new HttpError("Le service de vérification des risques est temporairement indisponible.", 503, false);
    }
  }

  public assessRiskFromRecaptchaScore(score: number | null | undefined): ISecurityEvaluationResult {
          // If score is null or undefined, treat it as high risk
          if (score === null || score === undefined   ) {
          return { isAllowed: false, requiredAction: 'BLOCK' };
          }
          // High risk
          if (score <= this.BLOCK_THRESHOLD) {
              return { isAllowed: false, requiredAction: 'BLOCK' };
          } 
          // Further verification required
          if (score < this.MFA_THRESHOLD) {
              return { isAllowed: false, requiredAction: 'MFA_REQUIRED' };
          }
          // Authorized (human)
          return { isAllowed: true, requiredAction: 'NONE' };
  }
}
